import chess
import evaluation
import time

# global variables for depth and time control
max_depth = 5
time_control = None
start_time = None

def set_depth(depth):
    global max_depth
    max_depth = depth

def set_time_control(tc):
    global time_control
    time_control = tc

def set_start_time():
    global start_time
    start_time = time.time()

# function to get remaining time 
def get_time_remaining():
    if start_time is None or time_control is None:
        return None
    return time_control - (time.time() - start_time)

# function to adjust depth based on remaining time
def adjust_depth(depth):
    time_remaining = get_time_remaining()
    if time_remaining < 30:
        depth = 1
    elif time_remaining < 60:
        depth = 2
    elif time_remaining < 120:
        depth = 3
    elif time_remaining < 240:
        depth = 4
    else:
        depth = max_depth
    return depth

def order_moves(board, moves):
    """
    Function to order moves based on their value, as determined by the evaluate_move function
    """
    move_value = [(move, evaluation.evaluate_move(move, board)) for move in moves]
    return [move for move, value in sorted(move_value, key=lambda x: x[1], reverse=True)]

def get_best_move(board, depth):
    """
    Function to get the best move for the current position using alpha beta pruning
    """
    global start_time, time_control
    if len(list(board.legal_moves)) == 1 or (time_control is not None and time.time() - start_time > time_control):
        return list(board.legal_moves)[0]

    alpha = -float("inf")
    beta = float("inf")
    best_move = None
    best_value = -float("inf")

    for move in order_moves(board, board.legal_moves):
        board.push(move)
        value = alpha_beta_pruning(board, depth - 1, alpha, beta, False)
        board.pop()

        if value > best_value:
            best_value = value
            best_move = move
    return best_move

def alpha_beta_pruning(board, depth, alpha, beta, maximizing_player):
    """
    Function to perform minimax search with alpha beta pruning, using the ordered moves
    generated by the order_moves function
    """
    # adjust the depth based on the remaining time
    depth = adjust_depth(depth)
    if depth == 0 or board.is_game_over():
        return evaluation.evaluate_position(board)

    if maximizing_player:
        best_value = -float("inf")
        for move in order_moves(board, board.legal_moves):
            board.push(move)
            value = alpha_beta_pruning(board, depth - 1, alpha, beta, False)
            board.pop()
            best_value = max(best_value, value)
            alpha = max(alpha, best_value)
            if alpha >= beta:
                break
        return best_value
    else:
        best_value = float("inf")
        for move in order_moves(board, board.legal_moves):
            board.push(move)
            value = alpha_beta_pruning(board, depth - 1, alpha, beta, True)
            board.pop()
            best_value = min(best_value, value)
            beta = min(beta, best_value)
            if alpha >= beta:
                break
        return best_value